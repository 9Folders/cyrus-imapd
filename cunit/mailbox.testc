#if HAVE_CONFIG_H
#include <config.h>
#endif
#if HAVE_STDALIGN_H
#include <stdalign.h>
#endif

#include "cunit/cyrunit.h"
#include "imap/mailbox.h"

/* XXX Time fields are time_t in memory, but are read from and written to
 * XXX disk in mailbox.c as bit32!  Don't fail for now, but we really ought
 * XXX to move to 64 bit time fields...
 * XXX Remove this kludge when the in memory and on disk types match.
 */
typedef bit32 XXX_TIME32_TYPE;

/* XXX quota_annot_used is quota_t (int64_t) in memory, but bit32 on disk */
typedef bit32 XXX_QUOTA32_TYPE;

/* XXX record cache_offset is 64b in memory but 32b on disk, and cache_version
 * XXX is 16b in memory but 32b on disk.
 */
typedef bit32 XXX_CACHE32_TYPE;

extern int verbose;

static void test_aligned_header_offsets(void)
{
#ifndef HAVE_STDALIGN_H
    if (verbose) {
        fputs("no C11 alignment macros, can't do anything useful\n", stderr);
    }
    return; /* can't do anything without C11 alignment macros */
#else
    struct index_header h;

    /* The order of the offsets tends to change over time, but the test does
     * not need to care about that.  Instead, keep this list sorted
     * alphabetically by the OFFSET_... name, for ease of maintenance.
     */
    CU_ASSERT_EQUAL(0, OFFSET_ANSWERED          % alignof(h.answered));
    CU_ASSERT_EQUAL(0, OFFSET_CHANGES_EPOCH     % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_DELETED           % alignof(h.deleted));
    CU_ASSERT_EQUAL(0, OFFSET_DELETEDMODSEQ     % alignof(h.deletedmodseq));
    CU_ASSERT_EQUAL(0, OFFSET_EXISTS            % alignof(h.exists));
    CU_ASSERT_EQUAL(0, OFFSET_FIRST_EXPUNGED    % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_FLAGGED           % alignof(h.flagged));
    CU_ASSERT_EQUAL(0, OFFSET_FORMAT            % alignof(h.format));
    CU_ASSERT_EQUAL(0, OFFSET_GENERATION_NO     % alignof(h.generation_no));
    CU_ASSERT_EQUAL(0, OFFSET_HEADER_CRC        % alignof(uint32_t)); /* not in struct */
    CU_ASSERT_EQUAL(0, OFFSET_HEADER_FILE_CRC   % alignof(h.header_file_crc));
    CU_ASSERT_EQUAL(0, OFFSET_HIGHESTMODSEQ     % alignof(h.highestmodseq));
    CU_ASSERT_EQUAL(0, OFFSET_LAST_APPENDDATE   % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_LAST_REPACK_TIME  % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_LAST_UID          % alignof(h.last_uid));
    CU_ASSERT_EQUAL(0, OFFSET_LEAKED_CACHE      % alignof(h.leaked_cache_records));
    CU_ASSERT_EQUAL(0, OFFSET_MAILBOX_CREATEDMODSEQ % alignof(h.createdmodseq));
    CU_ASSERT_EQUAL(0, OFFSET_MAILBOX_OPTIONS   % alignof(h.options));
    CU_ASSERT_EQUAL(0, OFFSET_MINOR_VERSION     % alignof(h.minor_version));
    CU_ASSERT_EQUAL(0, OFFSET_NUM_RECORDS       % alignof(h.num_records));
    CU_ASSERT_EQUAL(0, OFFSET_POP3_LAST_LOGIN   % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_POP3_SHOW_AFTER   % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_QUOTA_ANNOT_USED  % alignof(XXX_QUOTA32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_QUOTA_MAILBOX_USED % alignof(h.quota_mailbox_used));
    CU_ASSERT_EQUAL(0, OFFSET_RECENTTIME        % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_RECENTUID         % alignof(h.recentuid));
    CU_ASSERT_EQUAL(0, OFFSET_RECORD_SIZE       % alignof(h.record_size));
    CU_ASSERT_EQUAL(0, OFFSET_START_OFFSET      % alignof(h.start_offset));
    CU_ASSERT_EQUAL(0, OFFSET_SYNCCRCS_ANNOT    % alignof(h.synccrcs.annot));
    CU_ASSERT_EQUAL(0, OFFSET_SYNCCRCS_BASIC    % alignof(h.synccrcs.basic));
    CU_ASSERT_EQUAL(0, OFFSET_UIDVALIDITY       % alignof(h.uidvalidity));
    CU_ASSERT_EQUAL(0, OFFSET_UNSEEN            % alignof(h.unseen));
    /* this list is sorted alphabetically, don't just append */
#endif
}

static void test_aligned_record_offsets(void)
{
#ifndef HAVE_STDALIGN_H
    if (verbose) {
        fputs("no C11 alignment macros, can't do anything useful\n", stderr);
    }
    return; /* can't do anything without C11 alignment macros */
#else
    struct index_record r;

    /* The order of the offsets tends to change over time, but the test does
     * not need to care about that.  Instead, keep this list sorted
     * alphabetically by the OFFSET_... name, for ease of maintenance.
     */
    CU_ASSERT_EQUAL(0, OFFSET_CACHE_CRC     % alignof(r.cache_crc));
    CU_ASSERT_EQUAL(0, OFFSET_CACHE_OFFSET  % alignof(XXX_CACHE32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_CACHE_VERSION % alignof(XXX_CACHE32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_CREATEDMODSEQ % alignof(r.createdmodseq));
    CU_ASSERT_EQUAL(0, OFFSET_GMTIME        % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_HEADER_SIZE   % alignof(r.header_size));
    CU_ASSERT_EQUAL(0, OFFSET_INTERNALDATE  % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_LAST_UPDATED  % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_MESSAGE_GUID  % alignof(char)); /* r/w uses memcpy */
    CU_ASSERT_EQUAL(0, OFFSET_MODSEQ        % alignof(r.modseq));
    CU_ASSERT_EQUAL(0, OFFSET_RECORD_CRC    % alignof(uint32_t)); /* not in struct */
    CU_ASSERT_EQUAL(0, OFFSET_SAVEDATE      % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_SENTDATE      % alignof(XXX_TIME32_TYPE));
    CU_ASSERT_EQUAL(0, OFFSET_SIZE          % alignof(r.size));
    CU_ASSERT_EQUAL(0, OFFSET_SYSTEM_FLAGS  % alignof(r.system_flags));
    CU_ASSERT_EQUAL(0, OFFSET_THRID         % alignof(r.cid));
    CU_ASSERT_EQUAL(0, OFFSET_UID           % alignof(r.uid));
    CU_ASSERT_EQUAL(0, OFFSET_USER_FLAGS    % alignof(r.user_flags));
    /* this list is sorted alphabetically, don't just append */
#endif
}

static void test_header_size_multiple_of_modseq(void)
{
#ifndef HAVE_STDALIGN_H
    CU_ASSERT_EQUAL(0, INDEX_HEADER_SIZE % 8);
#else
    CU_ASSERT_EQUAL(0, INDEX_HEADER_SIZE % alignof(modseq_t));
#endif
}

static void test_record_size_multiple_of_modseq(void)
{
#ifndef HAVE_STDALIGN_H
    CU_ASSERT_EQUAL(0, INDEX_RECORD_SIZE % 8);
#else
    CU_ASSERT_EQUAL(0, INDEX_RECORD_SIZE % alignof(modseq_t));
#endif
}

/* vim: set ft=c: */
